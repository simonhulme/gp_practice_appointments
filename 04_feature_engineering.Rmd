---
title: "Feature Engineering"
output: html_notebook
---

```{r message=FALSE}
# Load libraries
library(tidyverse)
library(modeltime)
library(timetk)

# Read in raw Data
all_appointments <- read_rds("00_data/processed/wakefield_daily_corrected_tbl.rds")
events <- read_rds("00_data/processed/events_tbl.rds")
```

# Create Time Series

Decisions made:

Time period: Use post pandemic data as model to be used in recovery and post pandemic phase rather then modelling the impact of a pandemic.

GP: Other Practice staff heterogeneous group that is not sub-divided into professions. GP more straightforward to model using the available data

Attended: Reflects actual daily workload

5 day week vs 7 day with zero values for weekend: issues with zeros -TO DESCRIBE REASONS IN DETAIL

```{r}
gp_appts_tbl <-
    all_appointments %>%
    filter(hcp_type == "GP",
           appt_status == "Attended") %>%
    filter_by_time(.date_var = appointment_date, .start_date = "2021-07-20") %>% 
    summarise_by_time(
        .date_var = appointment_date,
        .by = "day",
        appointments = sum(count_of_appointments)
    ) %>% 
    left_join(events) %>% 
    filter(!weekend) %>% 
    select(-weekend, - pandemic)
   
gp_appts_tbl
```

### Visualise Time Series

```{r}
gp_appts_tbl %>% 
    plot_time_series(.date_var = appointment_date, .value = appointments)

gp_appts_tbl %>%
    plot_stl_diagnostics(
        .date_var = appointment_date,
        .value = appointments,
        .feature_set = c("season", "trend", "remainder")
    )
```

# Engineer features

Most striking features are weekly seasonality and events - bank holidays + training

Start by modelling these and then adding in longer term seasonal features

```{r}
time_feats_events_tbl <- 
    gp_appts_tbl %>% 
    mutate(wday.lbl  = wday(appointment_date, label = TRUE),
           month.lbl = month(appointment_date, label = TRUE),
           index.num = as.numeric(appointment_date))

time_feats_events_tbl
```

```{r}
# weekly seasonality and events
time_feats_events_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments ~ wday.lbl + bank_holiday + training,
        .show_summary = TRUE
    )
```

```{r}
# add monthly seasonality
time_feats_events_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments ~ wday.lbl + month.lbl + bank_holiday + training,
        .show_summary = TRUE
    )
```

Doesn't appear to be picking up trend

```{r}
# add linear trend
time_feats_events_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments ~ index.num + wday.lbl + month.lbl + bank_holiday + training,
        .show_summary = TRUE
    )

# add non linear trend - polynomial
time_feats_events_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments ~ poly(index.num, 4) + wday.lbl + month.lbl + bank_holiday + training,
        .show_summary = TRUE
    )

# add non linear trend - spline

time_feats_events_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments ~ splines::ns(index.num, df = 4) + wday.lbl + month.lbl + bank_holiday + training,
        .show_summary = TRUE
    )
```

This model accounts for trend and seasonality.

Next step is to build this model and explore its residuals to identify what other features may be needed

```{r}
trend_season_mdl <-
    lm(
        appointments ~ splines::ns(index.num, df = 4) + wday.lbl + month.lbl + bank_holiday + training,
        data = time_feats_events_tbl
    )

summary(trend_season_mdl)

## Explore results
trend_season_results <- 
    time_feats_events_tbl %>% 
    select(appointment_date, .observed = appointments, everything()) %>% 
    broom::augment(trend_season_mdl, data = .) %>% 
    mutate(.fitted = ifelse(bank_holiday, 0, .fitted)) %>% 
    mutate(.resid = .observed - .fitted)

trend_season_results %>% 
    select(.resid) %>% 
    ggplot(aes(.resid)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "grey30") +
    theme_bw()

trend_season_results %>% 
    select(.observed, .fitted) %>% 
    ggplot(aes(.observed, .fitted)) +
    geom_point(alpha = 0.5) +
    geom_abline() +
    theme_bw()

trend_season_results %>% 
    select(.fitted, .resid) %>% 
    ggplot(aes(.fitted, .resid)) +
    geom_point(alpha = 0.5) +
    geom_hline(yintercept = 0) +
    theme_bw()

trend_season_results %>% 
    select(appointment_date, .resid) %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = .resid, .lags = 365)
```

# Handling Autocorrelation

```{r}
trend_season_results %>% 
    select(appointment_date, .resid) %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = .resid, .lags = 1: 261)

time_feats_events_tbl %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = appointments, .lags = 1:261)
```

Add in some lagged terms for model although in real life this would be better captured using a time series model such as ARIMA. Using lagged terms limits ability of model to provide forecasts with small lags and reduces data to model with if large lags. Another option is to use fourier terms

```{r}
time_feats_events_lags_tbl <- 
    time_feats_events_tbl %>% 
    tk_augment_lags(.value = appointments, .lags = c(1:4)) %>% 
    tk_augment_lags(.value = bank_holiday, .lags = 1) %>% 
    tk_augment_lags(.value = training, .lags = 1) 

time_feats_events_lags_tbl %>% glimpse()
```

```{r}
time_feats_events_lags_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        .formula = appointments ~ splines::ns(index.num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + 
            appointments_lag1 + appointments_lag2 + appointments_lag3 + appointments_lag4 +
            bank_holiday_lag1 + training_lag1,
        .show_summary = TRUE
    )
```

```{r}
trend_season_events_lags_tbl_mdl <-
    lm(
        appointments ~ splines::ns(index.num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + 
            appointments_lag1 + appointments_lag2 + appointments_lag3 + appointments_lag4 +
            bank_holiday_lag1 + training_lag1,
        time_feats_events_lags_tbl
    )

summary(trend_season_events_lags_tbl_mdl)

## Explore results
trend_season_results <- 
    time_feats_events_lags_tbl %>% 
    drop_na() %>% 
    select(appointment_date, .observed = appointments, everything()) %>% 
    broom::augment(trend_season_events_lags_tbl_mdl, data = .) %>% 
    mutate(.fitted = ifelse(bank_holiday, 0, .fitted)) %>% 
    mutate(.resid = .observed - .fitted)


trend_season_results %>% 
    select(.resid) %>% 
    ggplot(aes(.resid)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "grey30") +
    theme_bw()

trend_season_results %>% 
    select(.observed, .fitted) %>% 
    ggplot(aes(.observed, .fitted)) +
    geom_point(alpha = 0.5) +
    geom_abline() +
    theme_bw()

trend_season_results %>%
    ggplot(aes(.fitted, .resid)) +
    geom_point(alpha = 0.5) +
    geom_hline(yintercept = 0) +
    theme_bw()

trend_season_results %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = .resid, .lags = 262)

anova(trend_season_events_lags_tbl_mdl)
```

Explore fourier terms for longer periods

```{r}
time_feats_events_lags_fourier_tbl <- 
    time_feats_events_lags_tbl %>% 
    tk_augment_fourier(.date_var = appointment_date, .periods = c(40))

time_feats_events_lags_fourier_tbl %>% glimpse()
```

```{r}
time_feats_events_lags_fourier_tbl %>% 
    plot_time_series_regression(
        .date_var = appointment_date,
        .formula = appointments ~ splines::ns(index.num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + 
            appointments_lag1 + appointments_lag2 + appointments_lag3 + appointments_lag4 +
            bank_holiday_lag1 + training_lag1 +
            appointment_date_sin40_K1 + appointment_date_cos40_K1,
        .show_summary = TRUE)
```

External Regressors and lagged external regressors

```{r}

time_feats_events_lags_xregs_tbl <- 
    time_feats_events_lags_tbl %>%
    left_join(gp_f2f_same_day_appointments %>% select(appointment_date, total_gp:registered_population))

## cross correlation
gp_f2f_same_day_xregs %>% 
    select(appointment_date, appointments, total_gp:registered_population) %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = appointments, .ccf_vars = c(total_gp:registered_population))
```
