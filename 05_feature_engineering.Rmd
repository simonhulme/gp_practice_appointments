---
title: "Feature Engineering"
output: html_notebook
---

```{r message=FALSE}
# Load libraries
library(tidyverse)
library(modeltime)
library(tidymodels)
library(timetk)

# Read in raw Data
appointments <- read_rds("00_data/processed/wakefield_weekdays_full.rds")
events       <- read_rds("00_data/processed/wakefield_events.rds")
population   <- read_rds("00_data/processed/wakefield_population_monthly.rds")
```

# Create Time Series

Decisions made:

Time period: Use post pandemic data as model to be used in recovery and post pandemic phase rather then modelling the impact of a pandemic.

GP: Other Practice staff heterogeneous group that is not sub-divided into professions. GP more straightforward to model using the available data

Attended: Reflects actual daily workload

5 day week vs 7 day with zero values for weekend: issues with zeros -TO DESCRIBE REASONS IN DETAIL

Also need to create training, testing and forecast data

```{r}
# convert monthly population into daily to join with appointments data
population_daily <-
    tibble(date = tk_make_weekday_sequence(
        min(appointments$appointment_date),
        max(appointments$appointment_date)
    )) %>% 
    left_join(population, by = c("date" = "extract_date")) %>% 
    fill(population,.direction = "down") %>% 
    fill(population,.direction = "up")
```

```{r}
# focus on all GP appointments attended by patients post pandemic
gp_appts_attended_tbl <-
    appointments %>%
    filter(hcp_type == "GP",
           appt_status == "Attended") %>%
    filter_by_time(.date_var = appointment_date, .start_date = "2021-07-20") %>% 
    summarise_by_time(
        .date_var = appointment_date,
        .by = "day",
        appointments = sum(count_of_appointments)
    ) 
```

```{r}
# transform response to adjust for population and to reduce variance
gp_appts_attended_transformed_tbl <- 
    gp_appts_attended_tbl %>%
    left_join(population_daily, by = c("appointment_date" = "date")) %>% 
    mutate(appointments_per_1k       = appointments / population * 1000,
           appointments_per_1k_trans = box_cox_vec(appointments_per_1k) %>% standardize_vec()) %>% 
    select(-appointments, -appointments_per_1k, -population)

params <- list(standardise = list(mean = 43.9927425754023, sd = 14.6194025360131),
               box_cox     = list(lambda = 1.99995900720725))
```

```{r}
# extend data into future (horizon 56 days)
data_prepared_full_tbl <-
    gp_appts_attended_transformed_tbl %>%
    bind_rows(future_frame(
        .data = .,
        .date_var = appointment_date,
        .length_out = 56
    )) %>%
    
    # join with events
    left_join(events,           by = c("appointment_date" = "event_date")) %>% 
    
    # create extra event - xmas eve
    mutate(xmas_eve = if_else(day(appointment_date) == 24 & month(appointment_date) == 12, 1, 0))
```

```{r}
# add event lags
data_prepared_full_tbl <- 
    data_prepared_full_tbl %>% 
    tk_augment_lags(.value = c(bank_holiday, training),
                    .lags = 1:3) %>% 
    drop_na(contains("lag"))
```

```{r}
train_test_tbl <- data_prepared_full_tbl %>% filter(!is.na(appointments_per_1k_trans))

splits <- 
    train_test_tbl %>% 
    time_series_split(date_var = appointment_date, assess = 40, cumulative = TRUE)

splits %>%
    tk_time_series_cv_plan() %>%
    plot_time_series_cv_plan(.date_var = appointment_date, .value = appointments_per_1k_trans)
```

```{r}
train_tbl    <- training(splits)
test_tbl     <- testing(splits)
forecast_tbl <- data_prepared_full_tbl %>% filter(is.na(appointments_per_1k_trans))
```

```{r}
# tidy up environment
rm(
    appointments,
    events,
    population,
    population_daily,
    splits,
    gp_appts_attended_tbl,
    gp_appts_attended_transformed_tbl
)
```

```{r}
## save new objects
# write_rds(gp_appts_attended_tbl, "00_data/processed/wakefield_gp_attended_post_pandemic.rds")
```

### Visualise Time Series

```{r}
train_tbl %>% 
    plot_time_series(.date_var = appointment_date, .value = appointments_per_1k_trans)

train_tbl %>%
    plot_stl_diagnostics(
        .date_var = appointment_date,
        .value = appointments_per_1k_trans,
        .feature_set = c("season", "trend", "remainder")
    )
```

# Engineer features

Most striking features are weekly seasonality and events - bank holidays + training

Start by modelling these and then adding in longer term seasonal features

```{r}
train_prepared_tbl <-
    train_tbl %>%
    mutate(
        index_num = as.numeric(appointment_date),
        wday.lbl  = wday(appointment_date, label = TRUE),
        month.lbl = month(appointment_date, label = TRUE)
    ) 
```

```{r}
# add seasonality plus events
train_prepared_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments_per_1k_trans ~ wday.lbl + month.lbl + bank_holiday + training + xmas_eve,
        .show_summary = TRUE
    )
```

```{r}
# add trend to seasonality and events

## linear 
train_prepared_tbl %>% 
     plot_time_series_regression(
        .date_var = appointment_date,
        appointments_per_1k_trans ~ index_num + 
            wday.lbl + month.lbl + 
            bank_holiday + training + xmas_eve,
        .show_summary = TRUE
    )


## non-linear trend - polynomial
train_prepared_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments_per_1k_trans ~ poly(index_num, 4) + 
            wday.lbl + month.lbl + 
            bank_holiday + training + xmas_eve,
        .show_summary = TRUE
    )

## non-linear trend - spline

train_prepared_tbl %>%
    plot_time_series_regression(
        .date_var = appointment_date,
        appointments_per_1k_trans ~ splines::ns(index_num, df = 4) + 
            wday.lbl + month.lbl + 
            bank_holiday + training + xmas_eve,
        .show_summary = TRUE
    )
```

```{r}
spline_time_events_mdl <-
    lm(
        appointments_per_1k_trans ~ splines::ns(index_num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + xmas_eve,
        data = train_prepared_tbl
    )

summary(spline_time_events_mdl)

## Explore results
spline_time_events_results <- 
    train_prepared_tbl %>% 
    select(appointment_date, .observed = appointments_per_1k_trans, everything()) %>% 
    broom::augment(spline_time_events_mdl, data = .) %>% 
    mutate(.resid = .observed - .fitted)

spline_time_events_results %>% 
    select(.resid) %>% 
    ggplot(aes(.resid)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "grey30") +
    theme_bw()

spline_time_events_results %>% 
    select(.observed, .fitted) %>% 
    ggplot(aes(.observed, .fitted)) +
    geom_point(alpha = 0.5) +
    geom_abline() +
    theme_bw()

p <- spline_time_events_results %>%
    select(appointment_date, .resid) %>%
    ggplot(aes(appointment_date, .resid)) +
    geom_line() +
    theme_bw()

plotly::ggplotly(p)
```

# Handling Autocorrelation

```{r}
spline_time_events_results %>% 
    select(appointment_date, .resid) %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = .resid, .lags = 0:262)

time_events_tbl %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = appointments_per_1k_trans, .lags = 0:262)
```

Could add in some lagged terms for model although in real life this would be better captured using a time series model such as ARIMA. Using lagged terms limits ability of model to provide forecasts with small lags and reduces data to model with if large lags. Another option is to use fourier terms

```{r}
# add in lagged event terms
train_prepared_tbl %>% 
    plot_time_series_regression(
        .date_var = appointment_date,
        .formula = appointments_per_1k_trans ~ splines::ns(index_num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + xmas_eve +
            bank_holiday_lag1 + bank_holiday_lag2 + bank_holiday_lag3 +
            training_lag1 + training_lag2 + training_lag3,
        .show_summary = TRUE
    )
```

```{r}
spline_time_events_with_lags_mdl <-
    lm(appointments_per_1k_trans ~ splines::ns(index_num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + xmas_eve +
            bank_holiday_lag1 + bank_holiday_lag2 + bank_holiday_lag3 +
            training_lag1 + training_lag2,
        train_prepared_tbl
    )

summary(spline_time_events_with_lags_mdl)

## Explore results
spline_time_events_with_lags_results <- 
    train_prepared_tbl %>% 
    select(appointment_date, .observed = appointments_per_1k_trans, everything()) %>% 
    broom::augment(spline_time_events_with_lags_mdl, data = .) %>% 
    mutate(.resid = .observed - .fitted)

spline_time_events_with_lags_results %>% 
    select(.resid) %>% 
    ggplot(aes(.resid)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "grey30") +
    theme_bw()

spline_time_events_with_lags_results %>% 
    select(.observed, .fitted) %>% 
    ggplot(aes(.observed, .fitted)) +
    geom_point(alpha = 0.3) +
    geom_abline() +
    theme_bw()

p <- spline_time_events_with_lags_results %>%
    select(appointment_date, .resid) %>%
    ggplot(aes(appointment_date, .resid)) +
    geom_line() +
    theme_bw()

plotly::ggplotly(p)

spline_time_events_with_lags_results %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = .resid, .lags = 262)

anova(spline_time_events_with_lags_mdl) %>% 
    broom::tidy() %>% 
    filter(p.value < 0.05) %>% 
    arrange(desc(meansq))
```

Explore fourier terms for longer periods

```{r}
train_prepared_tbl %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = appointments_per_1k_trans, .lags = 262)
```

```{r}
train_prepared_fourier_tbl <- 
    train_prepared_tbl %>% 
    tk_augment_fourier(.date_var = appointment_date, .periods = c(90, 260), .K = 1)
    
train_prepared_fourier_tbl %>% 
    plot_time_series_regression(
        .date_var = appointment_date,
        .formula = appointments_per_1k_trans ~ splines::ns(index_num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + 
            bank_holiday_lag1 + bank_holiday_lag2 + bank_holiday_lag3 +
            training_lag1 + training_lag2 + training_lag3 +
            # appointment_date_sin85_K1 + appointment_date_cos85_K1 +
            appointment_date_sin90_K1 + appointment_date_cos90_K1 +
            appointment_date_sin260_K1 + appointment_date_cos260_K1,
        .show_summary = TRUE)
```

```{r}
spline_time_events_with_lags_fourier_mdl<-
    lm(appointments_per_1k_trans ~ splines::ns(index_num, df = 4) + 
            wday.lbl + month.lbl +
            bank_holiday + training + xmas_eve +
            bank_holiday_lag1 + bank_holiday_lag2 + bank_holiday_lag3 +
            training_lag1 + training_lag2 +
            appointment_date_sin90_K1 + appointment_date_cos90_K1 +
            appointment_date_sin260_K1 + appointment_date_cos260_K1,
        train_prepared_fourier_tbl
    )

summary(spline_time_events_with_lags_fourier_mdl)

## Explore results
spline_time_events_with_lags_fourier_results <- 
    train_prepared_fourier_tbl %>% 
    select(appointment_date, .observed = appointments_per_1k_trans, everything()) %>% 
    broom::augment(spline_time_events_with_lags_fourier_mdl, data = .) %>% 
    mutate(.resid = .observed - .fitted)

spline_time_events_with_lags_fourier_results %>% 
    select(.resid) %>% 
    ggplot(aes(.resid)) +
    geom_histogram(bins = 30, fill = "skyblue", color = "grey30") +
    theme_bw()

spline_time_events_with_lags_fourier_results %>% 
    select(.observed, .fitted) %>% 
    ggplot(aes(.observed, .fitted)) +
    geom_point(alpha = 0.3) +
    geom_abline() +
    theme_bw()


spline_time_events_with_lags_fourier_results %>% 
    plot_acf_diagnostics(.date_var = appointment_date, .value = .resid, .lags = 262)

anova(time_events_with_lags_fourier_mdl)
```

```{r}
## Save best model
write_rds(spline_time_events_with_lags_fourier_mdl, "00_models/best_lm.rds")
write_rds(params, "00_models/params.rds")
```
